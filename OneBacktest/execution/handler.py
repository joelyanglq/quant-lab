from abc import ABC, abstractmethod
from datetime import datetime
import queue

from event import FillEvent, OrderEvent, EventType

class ExecutionHandler(ABC):
    """
    The ExecutionHandler abstract class handles the interaction
    between a set of order objects generated by a Portfolio and
    the ultimate execution of those orders in the market.

    The handlers can be used to simulate fill strategies or
    execute orders on a live brokerage.
    """

    @abstractmethod
    def execute_order(self, event: OrderEvent):
        """
        Takes an Order event and executes it, producing
        a Fill event that gets placed onto the Events queue.

        Parameters:
        event: Contains an Event object with order information.
        """
        raise NotImplementedError("Should implement execute_order()")

class SimulatedExecutionHandler(ExecutionHandler):
    """
    The simulated execution handler simply converts all order
    objects into their equivalent fill objects automatically
    without latency, slippage or fill-ratio issues.

    This allows a straightforward "first go" test of any strategy,
    before implementation with a more sophisticated execution
    handler.
    """
    
    def __init__(self, events: queue.Queue, data_handler):
        """
        Initializes the handler, setting the event queues
        up internally.

        Parameters:
        events: The Queue of Event objects.
        data_handler: The DataHandler object.
        """
        self.events = events
        self.data_handler = data_handler

    def execute_order(self, event: OrderEvent):
        """
        Simply converts Order objects into Fill objects naively,
        i.e. without any latency, slippage or fill ratio problems.

        Parameters:
        event: Contains an Event object with order information.
        """
        if event.event_type == EventType.ORDER:
            # Fetch current price
            bars = self.data_handler.get_latest_bars(event.symbol, N=1)
            if not bars.empty:
                fill_price = bars.iloc[-1]['close']
            else:
                fill_price = 0.0 # Should probably handle this better

            fill_event = FillEvent(
                event_id=str(id(object())),
                symbol=event.symbol,
                timestamp=datetime.now(), # In backtest this should ideally come from the order or market time
                quantity=event.quantity,
                side=event.side,
                fill_price=fill_price,
                commission=0.0,
                slippage=0.0
            )
            self.events.put(fill_event)
