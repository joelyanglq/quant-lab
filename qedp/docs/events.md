# Events Module

## Overview

The `events` module defines the communication protocol for the entire framework. Events are the "messages" that components use to communicate with each other. This event-driven design allows for loose coupling and makes the system highly modular and extensible.

## Core Concept: Events

An **event** is a timestamped notification that something happened or should happen in the system. Events are processed in chronological order and by priority.

## Event Types

### MarketEvent
Represents market data updates (price changes, volume, etc.).

**Fields:**
- `symbol`: The financial instrument (e.g., "AAPL")
- `etype`: Data type ("tick", "bar", "book")
- `payload`: The actual data (prices, volumes, etc.)

**Example:** "AAPL price is now $150.25 with volume 1000"

### SignalEvent
Trading signals generated by strategies.

**Fields:**
- `symbol`: Target instrument
- `intent`: What to do ("open", "close", "reduce", "flip")
- `target`: Position size (quantity or weight)
- `meta`: Additional strategy information

**Example:** "Buy 100 shares of AAPL"

### OrderEvent
Order submissions to the market.

**Fields:**
- `order_id`: Unique order identifier
- `symbol`: Instrument to trade
- `side`: "BUY" or "SELL"
- `type`: Order type ("MKT", "LMT", "STP", etc.)
- `qty`: Quantity to trade
- `px`: Limit price (for limit orders)
- `tif`: Time in force ("IOC", "FOK", "DAY", "GTC")

**Example:** "Market order to buy 100 AAPL shares"

### FillEvent
Order execution confirmations.

**Fields:**
- `order_id`: Which order was filled
- `symbol`: Instrument traded
- `fill_px`: Execution price
- `fill_qty`: Quantity filled
- `fees`: Trading costs
- `last_liquidity`: "ADD" or "REMOVE" (maker/taker)

**Example:** "Order #123 filled at $150.30 for 50 shares"

### CancelEvent
Order cancellation requests.

**Fields:**
- `order_id`: Which order to cancel

### AccountEvent
Portfolio/account status updates.

**Fields:**
- `balance`: Cash balance
- `margin`: Margin used
- `pnl_intraday`: Daily profit/loss
- `risk_limits`: Current risk constraints

### ClockEvent
Time progression and market session changes.

**Fields:**
- `phase`: Market phase ("pre", "open", "close", "after")
- `session_id`: Trading session identifier

### ControlEvent
System control commands.

**Fields:**
- `cmd`: Command ("pause", "resume", "stop", "reload")
- `args`: Command parameters

## Event Priority System

Events are processed in this order (highest to lowest priority):
1. **Control** - System commands (pause, stop)
2. **Clock** - Time progression
3. **Fill** - Order executions (most urgent)
4. **Cancel** - Order cancellations
5. **Order** - New orders
6. **Signal** - Trading signals
7. **Market** - Price data (least urgent)

## Design Principles

### Immutable Events
Once created, events cannot be modified, ensuring audit trails.

### Rich Metadata
Events carry all necessary context for processing.

### Type Safety
Strong typing prevents errors and improves IDE support.

## How Events Flow

### Typical Flow
1. **Data Feed** → MarketEvent (price data arrives)
2. **Strategy** → SignalEvent (generates trading idea)
3. **Portfolio** → OrderEvent (converts signal to order)
4. **Execution** → FillEvent (order gets executed)
5. **Portfolio** → AccountEvent (position updated)

### Event Chain Reactions
Handlers can generate new events in response to others, creating complex behaviors.

## Detailed Example with Input/Output Visualization

### Input: Trading Scenario
A strategy detects an oversold condition in AAPL and generates a buy signal. The portfolio converts this to an order, which gets filled.

### Step 1: Market Data Input
```python
# Raw market data arrives
market_data = {
    'timestamp': '2023-01-01 10:00:00',
    'symbol': 'AAPL',
    'price': 145.50,
    'volume': 500000
}
```

### Step 2: MarketEvent Creation (Data Module)
```python
from qedp.events.base import MarketEvent
import pandas as pd

market_event = MarketEvent(
    ts=pd.Timestamp(market_data['timestamp']),
    symbol=market_data['symbol'],
    etype='bar',
    payload={
        'close': market_data['price'],
        'volume': market_data['volume'],
        'open': 145.20,
        'high': 145.80,
        'low': 145.10
    }
)

print("Generated MarketEvent:")
print(market_event)
```

**Output:**
```
MarketEvent(ts=Timestamp('2023-01-01 10:00:00'), symbol='AAPL', etype='bar', payload={'close': 145.5, 'volume': 500000, 'open': 145.2, 'high': 145.8, 'low': 145.1}, priority=10)
```

### Step 3: SignalEvent Generation (Strategy Module)
```python
from qedp.events.base import SignalEvent

# Strategy logic: RSI < 30 indicates oversold
rsi_value = 25  # Calculated by strategy
if rsi_value < 30:
    signal_event = SignalEvent(
        ts=market_event.ts,
        symbol=market_event.symbol,
        intent='open',  # Open new position
        target={'qty': 100},  # Buy 100 shares
        meta={'rsi': rsi_value, 'strategy': 'mean_reversion'}
    )

print("Generated SignalEvent:")
print(signal_event)
```

**Output:**
```
SignalEvent(ts=Timestamp('2023-01-01 10:00:00'), symbol='AAPL', intent='open', target={'qty': 100}, meta={'rsi': 25, 'strategy': 'mean_reversion'}, priority=20)
```

### Step 4: OrderEvent Creation (Portfolio Module)
```python
from qedp.events.base import OrderEvent

order_event = OrderEvent(
    ts=signal_event.ts,
    order_id='AAPL_001_20230101',
    symbol=signal_event.symbol,
    side='BUY',
    type='MKT',  # Market order
    qty=signal_event.target['qty'],
    meta={'signal_id': 'mean_rev_001'}
)

print("Generated OrderEvent:")
print(order_event)
```

**Output:**
```
OrderEvent(ts=Timestamp('2023-01-01 10:00:00'), order_id='AAPL_001_20230101', symbol='AAPL', side='BUY', type='MKT', qty=100, px=None, tif='DAY', meta={'signal_id': 'mean_rev_001'}, priority=30)
```

### Step 5: FillEvent Generation (Execution Module)
```python
from qedp.events.base import FillEvent

# Simulate execution at $145.50
fill_event = FillEvent(
    ts=order_event.ts,
    order_id=order_event.order_id,
    symbol=order_event.symbol,
    fill_px=145.50,  # Execution price
    fill_qty=100,     # Full fill
    fees=1.45,        # $0.01 per share commission
    last_liquidity='ADD'  # Added liquidity (maker)
)

print("Generated FillEvent:")
print(fill_event)
```

**Output:**
```
FillEvent(ts=Timestamp('2023-01-01 10:00:00'), order_id='AAPL_001_20230101', symbol='AAPL', fill_px=145.50, fill_qty=100, fees=1.45, last_liquidity='ADD', meta={}, priority=50)
```

### Step 6: AccountEvent Update (Portfolio Module)
```python
from qedp.events.base import AccountEvent

account_event = AccountEvent(
    ts=fill_event.ts,
    balance=50000 - (100 * 145.50) - 1.45,  # Cash after purchase
    margin=0.0,  # No margin used
    pnl_intraday=0.0,  # No P&L yet
    risk_limits={'max_drawdown': 0.1, 'max_leverage': 2.0}
)

print("Generated AccountEvent:")
print(account_event)
```

**Output:**
```
AccountEvent(ts=Timestamp('2023-01-01 10:00:00'), balance=34548.55, margin=0.0, pnl_intraday=0.0, risk_limits={'max_drawdown': 0.1, 'max_leverage': 2.0}, priority=60)
```

### Complete Event Chain Visualization
```
Market Data Input
    ↓
1. MarketEvent (Data Feed)
    ↓
2. SignalEvent (Strategy Analysis)
    ↓
3. OrderEvent (Portfolio Decision)
    ↓
4. FillEvent (Execution)
    ↓
5. AccountEvent (Portfolio Update)
    ↓
Ready for Next Market Data
```

### Event Priority Processing Order
```
Timeline: 2023-01-01 10:00:00
├── Priority 10: MarketEvent (AAPL bar data)
├── Priority 20: SignalEvent (Buy 100 AAPL)
├── Priority 30: OrderEvent (Market buy order)
├── Priority 50: FillEvent (Order filled @ $145.50)
└── Priority 60: AccountEvent (Balance updated)
```

## Assumptions for Beginners

If you're new to event-driven systems:

- **Events as Messages**: Think of events as emails or notifications between system parts
- **Loose Coupling**: Components don't need to know about each other directly
- **Asynchronous Processing**: Events can be processed at different times
- **State Changes**: Events represent changes in the system's state
- **Audit Trail**: Every action is recorded as an event for later analysis

## Best Practices

- Keep events small and focused
- Include all necessary context in the event
- Use consistent naming conventions
- Handle events idempotently (processing multiple times is safe)
- Log events for debugging and analysis
